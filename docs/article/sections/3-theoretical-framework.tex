\section{Fundamentação Teórica}
\label{sec:fundamentacao}

Esta seção apresenta os conceitos que sustentam o design, a implementação e a validação empírica do ValorizeAI. São abordados princípios de design de software, fundamentos arquiteturais dos componentes utilizados e noções essenciais de Engenharia de Confiabilidade (SRE), que orientam a formulação dos SLOs e os experimentos descritos na metodologia.

\subsection{Princípios de Design de Software}
\label{sec:principios_design}

O desenvolvimento do ValorizeAI segue práticas consolidadas de engenharia de software, que visam reduzir acoplamento, aumentar coesão e facilitar evolução incremental da aplicação.

\subsubsection{Clean Architecture}
\label{sec:clean_architecture}

A \textit{Clean Architecture}, proposta por Martin \cite{martin_clean_2017}, defende a separação de responsabilidades através da \textit{Regra da Dependência}: detalhes variáveis, como frameworks e tecnologias de persistência, devem depender das regras de negócio, e não o contrário. No ValorizeAI, essa diretriz se manifesta na separação explícita entre lógica de domínio (Actions e Queries) e elementos de infraestrutura (controladores, Reverb, Redis e Cloud SQL).

\subsubsection{Domain-Driven Design (DDD)}
\label{sec:ddd}

O \textit{Domain-Driven Design} (DDD), de Evans \cite{evans_ddd_2003}, fornece estrutura semântica para lidar com domínios complexos. Os principais elementos aplicados são:

\begin{itemize}
    \item \textbf{Linguagem Ubíqua:} Modelo conceitual usado consistentemente por desenvolvedores e especialistas de domínio.
    \item \textbf{Contextos Delimitados:} Fronteiras que evitam ambiguidade e definem onde cada modelo é válido.
    \item \textbf{Agregados:} Unidades atômicas de consistência, manipuladas exclusivamente via sua \textit{Aggregate Root}.
\end{itemize}

Esses conceitos organizam o domínio do ValorizeAI e estruturam a modelagem de transações, contas e categorias.

\subsubsection{Segregação de Responsabilidades (CQRS e DTOs)}
\label{sec:cqrs_dto}

Para otimizar caminhos de leitura e escrita, o sistema adota \textit{Command Query Responsibility Segregation} (CQRS) \cite{fowler_cqrs_2011}. Consultas são tratadas por \textit{Queries} especializadas, que exploram Redis para acesso rápido; enquanto escritas passam por \textit{Actions}, que encapsulam regras de negócio, validações e persistência.

Complementarmente, são utilizados \textit{Data Transfer Objects} (DTOs) \cite{fowler_peaa_2002}, que isolam os dados expostos pela API dos modelos internos, reduzindo acoplamento e controlando a estrutura retornada ao front-end.

\subsection{Arquitetura e Componentes da Aplicação}
\label{sec:componentes_app}

A arquitetura do ValorizeAI combina serviços gerenciados que oferecem elasticidade, isolamento, baixo acoplamento e capacidade de processamento assíncrono.

\subsubsection{Google Cloud Run e Cloud Tasks}
\label{sec:cloud_run}

O Google Cloud Run é uma plataforma CaaS que executa contêineres \textit{stateless} com escalonamento automático, incluindo \textit{scale-to-zero} \cite{google_elasticity_2024}. No ValorizeAI, duas classes de contêineres são executadas: o serviço HTTP principal e o servidor WebSocket.

O Cloud Tasks implementa o componente assíncrono de EDA, enfileirando tarefas que exigem maior tempo de processamento. Isso permite que a API principal permaneça responsiva mesmo durante operações intensivas, delegando trabalho para \textit{workers} dedicados.

\subsubsection{Laravel Reverb (WebSockets)}
\label{sec:reverb}

O Laravel Reverb \cite{laravel_reverb_docs_2025} fornece um canal WebSocket de alta performance, apoiado no protocolo Pusher. O recurso central para este trabalho é sua capacidade de operar em múltiplas instâncias. Para permitir comunicação consistente entre esses nós efêmeros do Cloud Run, o Reverb utiliza Redis como \textit{backplane}, garantindo que eventos emitidos por qualquer instância sejam entregues aos clientes conectados em outra.

\subsubsection{Redis (Cache e Pub/Sub)}
\label{sec:redis}

O Redis, um armazenamento em memória de baixa latência \cite{kleppmann_ddia_2017}, exerce dois papéis complementares:

\begin{enumerate}
    \item \textbf{Cache de leitura:} Acelera consultas críticas, reduzindo carga sobre o Cloud SQL.
    \item \textbf{Pub/Sub:} Atua como barramento de mensagens para sincronizar múltiplas instâncias do Reverb.
\end{enumerate}

Essas funções são essenciais para garantir que operações de leitura permaneçam dentro dos SLOs e que notificações em tempo real sejam entregues sem violação de consistência.

\subsection{Engenharia de Confiabilidade de Sites (SRE)}
\label{sec:sre}

A metodologia de validação do ValorizeAI segue os princípios de SRE apresentados pelo Google \cite{google_sre_book_main}. O SRE trata confiabilidade como uma disciplina quantitativa, guiada por indicadores e metas formalizadas.

\subsubsection{SLIs, SLOs e Orçamento de Erro}
\label{sec:slo_sli}

Três conceitos embasam os experimentos:

\begin{itemize}
    \item \textbf{SLI (Service Level Indicator):} Métrica quantitativa que representa a qualidade de uma operação, como latência P95, taxa de erro ou \textit{throughput} \cite{mccoy_slo_2020}.
    \item \textbf{SLO (Service Level Objective):} Meta operacional definida para um SLI. Ex.: ``95\% das leituras com latência \textless 300 ms''.
    \item \textbf{Orçamento de Erro:} Tolerância máxima para falhas dentro do período do SLO, definindo quando priorizar evolução ou estabilidade.
\end{itemize}

Esses conceitos orientam os testes de carga apresentados na Seção~\ref{sec:metodologia}, guiando a análise de saturação, violações de SLO e comportamento do sistema sob tráfego intenso.

